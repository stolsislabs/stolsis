// Generated by dojo-bindgen on Sat, 21 Sep 2024 20:09:29 +0000. Do not modify this file manually.
// Import the necessary types from the recs SDK
// generate again with `sozo build --typescript`
import { Account, byteArray } from "starknet";
import { DojoProvider, getContractByName } from "@dojoengine/core";
import * as models from "./models.gen";
import { dojoConfig } from "../../../dojo.config";

export type IWorld = Awaited<ReturnType<typeof setupWorld>>;

export async function setupWorld(provider: DojoProvider) {
  // System definitions for `paved-Account` contract
  function Account() {
    const contract_name = "Account";
    const fee_token_name = "Token";

    // Call the `world` system with the specified Account and calldata
    const world = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "world",
            calldata: [],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing world:", error);
        throw error;
      }
    };

    // Call the `create` system with the specified Account and calldata
    const create = async (props: {
      account: Account;
      name: bigint;
      master: bigint;
    }) => {
      try {
        return await provider.execute(
          props.account,
          [
            {
              contractName: fee_token_name,
              entrypoint: "mint",
              calldata: [],
            },
            {
              contractName: contract_name,
              entrypoint: "create",
              calldata: [props.name, props.master],
            },
          ],
          "paved",
        );
      } catch (error) {
        console.error("Error executing create:", error);
        throw error;
      }
    };

    return {
      world,
      create,
    };
  }

  // System definitions for `paved-Daily` contract
  function Daily() {
    const config = dojoConfig();
    const contract_name = "Daily";
    const contract_address = getContractByName(
      config.manifest,
      "paved",
      contract_name,
    )?.address;
    const fee_token_name = "Token";

    // Call the `world` system with the specified Account and calldata
    const world = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "world",
            calldata: [],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing world:", error);
        throw error;
      }
    };

    // Call the `spawn` system with the specified Account and calldata
    const spawn = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          [
            {
              contractName: fee_token_name,
              entrypoint: "approve",
              calldata: [contract_address, `0x${(1e18).toString(16)}`, "0x0"],
            },
            {
              contractName: contract_name,
              entrypoint: "spawn",
              calldata: [],
            },
          ],
          "paved",
        );
      } catch (error) {
        console.error("Error executing spawn:", error);
        throw error;
      }
    };

    // Call the `claim` system with the specified Account and calldata
    const claim = async (props: {
      account: Account;
      tournament_id: number;
      rank: number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "claim",
            calldata: [props.tournament_id, props.rank],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing claim:", error);
        throw error;
      }
    };

    // Call the `sponsor` system with the specified Account and calldata
    const sponsor = async (props: { account: Account; amount: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          [
            {
              contractAddress: config.feeTokenAddress,
              entrypoint: "approve",
              calldata: [contract_address, props.amount, "0x0"],
            },
            {
              contractName: contract_name,
              entrypoint: "sponsor",
              calldata: [props.amount],
            },
          ],
          "paved",
        );
      } catch (error) {
        console.error("Error executing sponsor:", error);
        throw error;
      }
    };

    // Call the `discard` system with the specified Account and calldata
    const discard = async (props: { account: Account; game_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "discard",
            calldata: [props.game_id],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing discard:", error);
        throw error;
      }
    };

    // Call the `surrender` system with the specified Account and calldata
    const surrender = async (props: { account: Account; game_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "surrender",
            calldata: [props.game_id],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing surrender:", error);
        throw error;
      }
    };

    // Call the `build` system with the specified Account and calldata
    const build = async (props: {
      account: Account;
      game_id: number;
      orientation: number;
      x: number;
      y: number;
      role: number;
      spot: number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "build",
            calldata: [
              props.game_id,
              props.orientation,
              props.x,
              props.y,
              props.role,
              props.spot,
            ],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing build:", error);
        throw error;
      }
    };

    return {
      world,
      spawn,
      claim,
      sponsor,
      discard,
      surrender,
      build,
    };
  }

  // System definitions for `paved-Tutorial` contract
  function Tutorial() {
    const contract_name = "Tutorial";

    // Call the `world` system with the specified Account and calldata
    const world = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "world",
            calldata: [],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing world:", error);
        throw error;
      }
    };

    // Call the `spawn` system with the specified Account and calldata
    const spawn = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "spawn",
            calldata: [],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing spawn:", error);
        throw error;
      }
    };

    // Call the `discard` system with the specified Account and calldata
    const discard = async (props: { account: Account; game_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "discard",
            calldata: [props.game_id],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing discard:", error);
        throw error;
      }
    };

    // Call the `surrender` system with the specified Account and calldata
    const surrender = async (props: { account: Account; game_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "surrender",
            calldata: [props.game_id],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing surrender:", error);
        throw error;
      }
    };

    // Call the `build` system with the specified Account and calldata
    const build = async (props: { account: Account; game_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "build",
            calldata: [props.game_id],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing build:", error);
        throw error;
      }
    };

    return {
      world,
      spawn,
      discard,
      surrender,
      build,
    };
  }

  // System definitions for `paved-Weekly` contract
  function Weekly() {
    const config = dojoConfig();
    const contract_name = "Weekly";
    const contract_address = getContractByName(
      config.manifest,
      "paved",
      contract_name,
    )?.address;
    const fee_token_name = "Token";

    // Call the `spawn` system with the specified Account and calldata
    const spawn = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          [
            {
              contractName: fee_token_name,
              entrypoint: "approve",
              calldata: [contract_address, `0x${(1e18).toString(16)}`, "0x0"],
            },
            {
              contractName: contract_name,
              entrypoint: "spawn",
              calldata: [],
            },
          ],
          "paved",
        );
      } catch (error) {
        console.error("Error executing spawn:", error);
        throw error;
      }
    };

    // Call the `claim` system with the specified Account and calldata
    const claim = async (props: {
      account: Account;
      tournament_id: number;
      rank: number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "claim",
            calldata: [props.tournament_id, props.rank],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing claim:", error);
        throw error;
      }
    };

    // Call the `sponsor` system with the specified Account and calldata
    const sponsor = async (props: { account: Account; amount: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          [
            {
              contractAddress: config.feeTokenAddress,
              entrypoint: "approve",
              calldata: [contract_address, props.amount, "0x0"],
            },
            {
              contractName: contract_name,
              entrypoint: "sponsor",
              calldata: [props.amount],
            },
          ],
          "paved",
        );
      } catch (error) {
        console.error("Error executing sponsor:", error);
        throw error;
      }
    };

    // Call the `discard` system with the specified Account and calldata
    const discard = async (props: { account: Account; game_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "discard",
            calldata: [props.game_id],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing discard:", error);
        throw error;
      }
    };

    // Call the `surrender` system with the specified Account and calldata
    const surrender = async (props: { account: Account; game_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "surrender",
            calldata: [props.game_id],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing surrender:", error);
        throw error;
      }
    };

    // Call the `build` system with the specified Account and calldata
    const build = async (props: {
      account: Account;
      game_id: number;
      orientation: number;
      x: number;
      y: number;
      role: number;
      spot: number;
    }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "build",
            calldata: [
              props.game_id,
              props.orientation,
              props.x,
              props.y,
              props.role,
              props.spot,
            ],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing build:", error);
        throw error;
      }
    };

    // Call the `world` system with the specified Account and calldata
    const world = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "world",
            calldata: [],
          },
          "paved",
        );
      } catch (error) {
        console.error("Error executing world:", error);
        throw error;
      }
    };

    return {
      spawn,
      claim,
      sponsor,
      discard,
      surrender,
      build,
      world,
    };
  }

  return {
    account: Account(),
    daily: Daily(),
    tutorial: Tutorial(),
    weekly: Weekly(),
  };
}
