/* Autogenerated file. Do not edit manually. */

import {
  num,
  GetTransactionReceiptResponse,
  InvokeTransactionReceiptResponse,
  SuccessfulTransactionReceiptResponse,
  Contract,
} from "starknet";

export enum WorldEvents {
  Built = "0x1d45258cfbc6a05a3a95aca416a9a9870a252afc3323a488c5e49221d6bad6f",
  Scored = "0x1f5f91de9e33f581e67e239e952691057fe8e45631568808fa00d0bda38cce9",
  Discarded = "0x9e199bdedd47e8aab3606d9c16c4423368e1500697a07ac8e076f7a28419d0",
  GameOver = "0x165460ded86991fa560a0d331810f83651da90c5df6d4b61357c3b3807ff41c",
}

export interface BaseEventData {
  game_id: number;
  event_type: WorldEvents;
  event_name: string;
}

export interface BuiltData extends BaseEventData {
  game_id: number;
  tile_id: number;
  x: number;
  y: number;
  player_id: string;
  player_name: string;
}

export interface ScoredData extends BaseEventData {
  game_id: number;
  tile_id: number;
  x: number;
  y: number;
  player_id: string;
  player_name: string;
  order_id: number;
  points: number;
}

export interface DiscardedData extends BaseEventData {
  game_id: number;
  tile_id: number;
  player_id: string;
  player_name: string;
  order_id: number;
  points: number;
}

export interface GameOverData extends BaseEventData {
  game_id: number;
  tournament_id: number;
  game_score: number;
  game_start_time: number;
  game_end_time: number;
  player_id: string;
  player_name: string;
  player_master: string;
}

export const parseAllEvents = (receipt: GetTransactionReceiptResponse) => {
  if (receipt.status === "REJECTED") {
    throw new Error(`transaction REJECTED`);
  }
  if (receipt.status === "REVERTED") {
    throw new Error(`transaction REVERTED`);
  }

  const flatEvents = parseEvents(
    receipt as SuccessfulTransactionReceiptResponse
  );
  return flatEvents;
};

export const parseEvents = (receipt: SuccessfulTransactionReceiptResponse) => {
  const parsed = receipt.events.map((e) => parseEvent(e));
  return parsed;
};

export type ParseEventResult = ReturnType<typeof parseEvent>;

export const parseEvent = (raw: any) => {
  switch (raw.keys[0]) {
    case WorldEvents.Built:
      return {
        event_type: WorldEvents.Built,
        event_name: "Built",
        game_id: Number(raw.keys[1]),
        tile_id: Number(raw.data[0]),
        x: Number(raw.data[1]),
        y: Number(raw.data[2]),
        player_id: num.toHexString(raw.data[3]),
        player_name: num.toHexString(raw.data[4]),
      } as BuiltData;

    case WorldEvents.Scored:
      return {
        event_type: WorldEvents.Scored,
        event_name: "Scored",
        game_id: Number(raw.keys[1]),
        tile_id: Number(raw.data[0]),
        x: Number(raw.data[1]),
        y: Number(raw.data[2]),
        player_id: num.toHexString(raw.data[3]),
        player_name: num.toHexString(raw.data[4]),
        order_id: Number(raw.data[5]),
        points: Number(raw.data[6]),
      } as ScoredData;

    case WorldEvents.Discarded:
      return {
        event_type: WorldEvents.Discarded,
        event_name: "Discarded",
        game_id: Number(raw.keys[1]),
        tile_id: Number(raw.data[0]),
        player_id: num.toHexString(raw.data[1]),
        player_name: num.toHexString(raw.data[2]),
        order_id: Number(raw.data[3]),
        points: Number(raw.data[4]),
      } as DiscardedData;

    case WorldEvents.GameOver:
      return {
        event_type: WorldEvents.GameOver,
        event_name: "GameOver",
        game_id: Number(raw.keys[1]),
        tournament_id: Number(raw.keys[2]),
        game_score: Number(raw.data[0]),
        game_start_time: Number(raw.data[1]),
        game_end_time: Number(raw.data[2]),
        player_id: num.toHexString(raw.data[3]),
        player_name: num.toHexString(raw.data[4]),
        player_master: num.toHexString(raw.data[5]),
      } as GameOverData;

    default:
      return {
        gameId: undefined,
        event_type: raw.keys[0],
        event_name: raw.keys[0],
      };
      break;
  }
};
