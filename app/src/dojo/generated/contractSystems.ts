// Generated by dojo-bindgen on Thu, 19 Sep 2024 17:13:23 +0000. Do not modify this file manually.
// Import the necessary types from the recs SDK
// generate again with `sozo build --typescript` 
import { Account, byteArray } from "starknet";
import { DojoProvider, getContractByName } from "@dojoengine/core";
import * as models from "./contractModels";
import { dojoConfig } from "../../../dojo.config";

export type IWorld = Awaited<ReturnType<typeof setupWorld>>;

export async function setupWorld(provider: DojoProvider) {
  // System definitions for `paved-account` contract
  function account() {
    const contract_name = "account";
    const fee_token_name = "token";

    // Call the `world` system with the specified Account and calldata
    const world = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "world",
            calldata: [],
          },
          "paved"
        );
      } catch (error) {
        console.error("Error executing world:", error);
        throw error;
      }
    };



    // Call the `create` system with the specified Account and calldata
    const create = async (props: { account: Account, name: bigint, master: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          [
            {
              contractName: fee_token_name,
              entrypoint: "mint",
              calldata: [],
            },
            {
              contractName: contract_name,
              entrypoint: "create",
              calldata: [props.name,
              props.master],
            },
          ],
          "paved"
        );
      } catch (error) {
        console.error("Error executing create:", error);
        throw error;
      }
    };


    return {
      world, create
    };
  }

  // System definitions for `paved-daily` contract
  function daily() {
    const config = dojoConfig();
    const contract_name = "daily";
    const contract_address = getContractByName(config.manifest, 'paved', contract_name)?.address;
    const fee_token_name = "token";


    // Call the `spawn` system with the specified Account and calldata
    const spawn = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          [
            {
              contractName: fee_token_name,
              entrypoint: "approve",
              calldata: [contract_address, `0x${(1e18).toString(16)}`, "0x0"],
            },
            {
              contractName: contract_name,
              entrypoint: "spawn",
              calldata: [],
            },
          ],
          "paved"
        );
      } catch (error) {
        console.error("Error executing spawn:", error);
        throw error;
      }
    };



    // Call the `claim` system with the specified Account and calldata
    const claim = async (props: { account: Account, tournament_id: number, rank: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "claim",
            calldata: [props.tournament_id,
            props.rank],
          },
          "paved"
        );
      } catch (error) {
        console.error("Error executing claim:", error);
        throw error;
      }
    };



    // Call the `sponsor` system with the specified Account and calldata
    const sponsor = async (props: { account: Account, amount: bigint }) => {
      try {
        return await provider.execute(
          props.account,

          [
            {
              contractAddress: config.feeTokenAddress,
              entrypoint: "approve",
              calldata: [contract_address, props.amount, "0x0"],
            },
            {
              contractName: contract_name,
              entrypoint: "sponsor",
              calldata: [props.amount],
            },
          ],
          "paved"
        );
      } catch (error) {
        console.error("Error executing sponsor:", error);
        throw error;
      }
    };



    // Call the `discard` system with the specified Account and calldata
    const discard = async (props: { account: Account, game_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "discard",
            calldata: [props.game_id],
          },
          "paved"
        );
      } catch (error) {
        console.error("Error executing discard:", error);
        throw error;
      }
    };



    // Call the `surrender` system with the specified Account and calldata
    const surrender = async (props: { account: Account, game_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "surrender",
            calldata: [props.game_id],
          },
          "paved"
        );
      } catch (error) {
        console.error("Error executing surrender:", error);
        throw error;
      }
    };



    // Call the `build` system with the specified Account and calldata
    const build = async (props: { account: Account, game_id: number, orientation: models.Orientation, x: number, y: number, role: models.Role, spot: models.Spot }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "build",
            calldata: [props.game_id,
            props.orientation,
            props.x,
            props.y,
            props.role,
            props.spot],
          },
          "paved"
        );
      } catch (error) {
        console.error("Error executing build:", error);
        throw error;
      }
    };



    // Call the `world` system with the specified Account and calldata
    const world = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "world",
            calldata: [],
          },
          "paved"
        );
      } catch (error) {
        console.error("Error executing world:", error);
        throw error;
      }
    };


    return {
      spawn, claim, sponsor, discard, surrender, build, world
    };
  }

  // System definitions for `paved-token` contract
  function token() {
    const contract_name = "token";


    // Call the `total_supply` system with the specified Account and calldata
    const total_supply = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "total_supply",
            calldata: [],
          },
          "paved"
        );
      } catch (error) {
        console.error("Error executing total_supply:", error);
        throw error;
      }
    };



    // Call the `balance_of` system with the specified Account and calldata
    const balance_of = async (props: { account: Account, account: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "balance_of",
            calldata: [props.account],
          },
          "paved"
        );
      } catch (error) {
        console.error("Error executing balance_of:", error);
        throw error;
      }
    };



    // Call the `allowance` system with the specified Account and calldata
    const allowance = async (props: { account: Account, owner: bigint, spender: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "allowance",
            calldata: [props.owner,
            props.spender],
          },
          "paved"
        );
      } catch (error) {
        console.error("Error executing allowance:", error);
        throw error;
      }
    };



    // Call the `transfer` system with the specified Account and calldata
    const transfer = async (props: { account: Account, recipient: bigint, amount: models.U256 }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "transfer",
            calldata: [props.recipient,
            props.amount],
          },
          "paved"
        );
      } catch (error) {
        console.error("Error executing transfer:", error);
        throw error;
      }
    };



    // Call the `transfer_from` system with the specified Account and calldata
    const transfer_from = async (props: { account: Account, sender: bigint, recipient: bigint, amount: models.U256 }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "transfer_from",
            calldata: [props.sender,
            props.recipient,
            props.amount],
          },
          "paved"
        );
      } catch (error) {
        console.error("Error executing transfer_from:", error);
        throw error;
      }
    };



    // Call the `approve` system with the specified Account and calldata
    const approve = async (props: { account: Account, spender: bigint, amount: models.U256 }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "approve",
            calldata: [props.spender,
            props.amount],
          },
          "paved"
        );
      } catch (error) {
        console.error("Error executing approve:", error);
        throw error;
      }
    };



    // Call the `name` system with the specified Account and calldata
    const name = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "name",
            calldata: [],
          },
          "paved"
        );
      } catch (error) {
        console.error("Error executing name:", error);
        throw error;
      }
    };



    // Call the `symbol` system with the specified Account and calldata
    const symbol = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "symbol",
            calldata: [],
          },
          "paved"
        );
      } catch (error) {
        console.error("Error executing symbol:", error);
        throw error;
      }
    };



    // Call the `decimals` system with the specified Account and calldata
    const decimals = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "decimals",
            calldata: [],
          },
          "paved"
        );
      } catch (error) {
        console.error("Error executing decimals:", error);
        throw error;
      }
    };



    // Call the `totalSupply` system with the specified Account and calldata
    const totalSupply = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "totalSupply",
            calldata: [],
          },
          "paved"
        );
      } catch (error) {
        console.error("Error executing totalSupply:", error);
        throw error;
      }
    };



    // Call the `balanceOf` system with the specified Account and calldata
    const balanceOf = async (props: { account: Account, account: bigint }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "balanceOf",
            calldata: [props.account],
          },
          "paved"
        );
      } catch (error) {
        console.error("Error executing balanceOf:", error);
        throw error;
      }
    };



    // Call the `transferFrom` system with the specified Account and calldata
    const transferFrom = async (props: { account: Account, sender: bigint, recipient: bigint, amount: models.U256 }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "transferFrom",
            calldata: [props.sender,
            props.recipient,
            props.amount],
          },
          "paved"
        );
      } catch (error) {
        console.error("Error executing transferFrom:", error);
        throw error;
      }
    };



    // Call the `world` system with the specified Account and calldata
    const world = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "world",
            calldata: [],
          },
          "paved"
        );
      } catch (error) {
        console.error("Error executing world:", error);
        throw error;
      }
    };


    return {
      total_supply, balance_of, allowance, transfer, transfer_from, approve, name, symbol, decimals, totalSupply, balanceOf, transferFrom, world
    };
  }

  // System definitions for `paved-tutorial` contract
  function tutorial() {
    const contract_name = "tutorial";


    // Call the `spawn` system with the specified Account and calldata
    const spawn = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "spawn",
            calldata: [],
          },
          "paved"
        );
      } catch (error) {
        console.error("Error executing spawn:", error);
        throw error;
      }
    };



    // Call the `discard` system with the specified Account and calldata
    const discard = async (props: { account: Account, game_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "discard",
            calldata: [props.game_id],
          },
          "paved"
        );
      } catch (error) {
        console.error("Error executing discard:", error);
        throw error;
      }
    };



    // Call the `surrender` system with the specified Account and calldata
    const surrender = async (props: { account: Account, game_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "surrender",
            calldata: [props.game_id],
          },
          "paved"
        );
      } catch (error) {
        console.error("Error executing surrender:", error);
        throw error;
      }
    };



    // Call the `build` system with the specified Account and calldata
    const build = async (props: { account: Account, game_id: number }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "build",
            calldata: [props.game_id],
          },
          "paved"
        );
      } catch (error) {
        console.error("Error executing build:", error);
        throw error;
      }
    };



    // Call the `world` system with the specified Account and calldata
    const world = async (props: { account: Account }) => {
      try {
        return await provider.execute(
          props.account,
          {
            contractName: contract_name,
            entrypoint: "world",
            calldata: [],
          },
          "paved"
        );
      } catch (error) {
        console.error("Error executing world:", error);
        throw error;
      }
    };


    return {
      spawn, discard, surrender, build, world
    };
  }

  return {
    account: account(),
    daily: daily(),
    token: token(),
    tutorial: tutorial()
  };
}